\subsection{Additional Tools}
\label{sec:tools}

Here, we will list some additional tools that were used in the context of this project.

\subsubsection{Extempore}
\label{sec:tools.extempore}

Extempore \cite{extempore} is a programming environment for live coding.
It features a scheme interpreter and a just-in-time compiler for its own language xtlang, a low-level language with a Lisp syntax.
Scheme is usually used for application logic such as algorithmic composition or application control while xtlang allows to program the synthesis of sound, displaying of graphics, or other computations with real-time requirements.

Sound is created by defining the \texttt{dsp} function which takes inputs like a time code, an input sample, and a channel and returns an output sample.
The way in which the output sample is generated is left to the programmer and can include, for example, synthesis or sampling.
Extempore's standard library provides help for the sound generation on the sample level as well as composition on the note level (scales, chords, etc.).
One core idea of Extempore is the concept of temporal recursion: a function can schedule another call to itself at a later point in time creating a loop with exact timing that can be modified on the fly.

In the context of this project, Extempore is used for making a style audible as described in Section \ref{sec:viewers.extempore}.

\subsubsection{Music21}
\label{sec:tools.music21}

Music21 \cite{music21} is a Python library for the computational analysis of music.
It includes a set of annotated corpora and analysis tools as well as general music theoretical utilities.
Data from the corpora can be accessed as Python objects and transformed, manipulated, and analyzed in Python.
The example style \texttt{coltrane.json} has been generated using Music21.

\subsubsection{Lilypond}
\label{sec:tools.lilypond}

\textit{Is this used at all?}

\subsubsection{Musescore}

MuseScore \cite{musescore} is an open source music sheet editor.
It can display and play sheet music and supports MusicXML and Lilypond formats.
This project uses it to view and listen to MusicXML representations of styles.
Another idea was to make the harmonizer available as a plugin in MuseScore.

\subsection{Related Research}

\subsubsection{Rohrmeier}

\subsubsection{Koops - \textsc{HarmTrace}}
The work by \cite{koops2012} is a model based system to derive harmonic functions of chords in their tonal context and consists of \textsc{HarmTrace} and the \textsc{HarmTrace Harmonizer}. It is a rule based system written in the programming language Haskell. Given a chord sequence \textsc{HarmTrace} derives the harmonic function of the of a chord in it's tonal context. It describes a grammar to represent chords and the relations between them in them. Based on this representation the \textsc{Harmonizer} creates the best fitting chord sequence to harmonize the melody.

The system involves three steps. First the melody is analyzed using the \textsc{HarmTrace} program. After that the tonality and the and the time signature of the music piece is represented in a data structure that defines a context free grammar. After that the best sequences of chords are selected using the \textsc{HarmTrace Harmonizer}. 

This selection is based on basic heuristics form the harmonization theory, like the circle of fifths and cadences. The system includes four steps: Generating, Selection, Parsing and Post-processing. 

\paragraph{Generating} 
The system takes as single track as input and extracts tonality and rhythm information of the piece using the \textsc{HarmTrace} module and represents it in the context free grammar. In this representation the possible chords are calculated for the root note and a pre-selection is done. Next the probabilities are assigned to the chords in the remaining set, which are calculated using the circle of fifths, where the distance of the melody note to the root note gives the probability. The circle of fifths is used because it corresponds with human perception of harmony. 

\paragraph{Selecting sequences}
In the next step the probabilities are used to generate a list of possible harmonization chord sequences. The list is generated by randomly selecting from the chord candidates. The probability distribution for that is defined by the chord probabilities, calculated before. 

\paragraph{Parsing}
In this step the short chord sequences are combined to a lager piece using the \textsc{HarmTrace} parsing capabilities, so that the best sequence of chords progressions if returned. The best sequence is determined by the best fit with the grammar.

\paragraph{Post-processing}
In the final step the symbolic representation of the music piece is translated in the MIDI format. For that some heuristics are used to ensure that the resulting piece will sound good. 

\paragraph{Relation to our work}
This work is related to our project it the sense that is also uses a symbolic representation of music and creates harmonization of the piece automatically. Similar to our work Koops uses representations to generate new chords and sequences. He also represents the chords in therms of relive distance between the tone and the root similar to our representation.

Other then in our work he uses a pre-selection step to exclude chord sequences from the pool if generated chords. This is done by using the concept of cadences and the circle of fifths. That way he wants to ensure that the result is not bad by chance. We instead regularize the output by giving the system only the limited number of sequences to work with, that are the styles we put in the system at the start. 

Koops also uses the circle of fifths in combination with a stochastic selection to generate new sequences, this is a good idea to ensure that the result will sound good. The disadvantage of this approach is that the result wouldn't sound interesting because it favors the close and common chords. Because of this random generation paired with a strong heuristics selection the system is not inventive enough for us to grant creativity to it.





  