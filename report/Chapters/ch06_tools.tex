\subsection{Additional Tools}
\label{sec:tools}

Here, we will list some additional tools that were used in the context of this project.

\subsubsection{Extempore}
\label{sec:tools.extempore}

Extempore \cite{extempore} is a programming environment for live coding.
It features a scheme interpreter and a just-in-time compiler for its own language xtlang, a low-level language with a Lisp syntax.
Scheme is usually used for application logic such as algorithmic composition or application control while xtlang allows to program the synthesis of sound, displaying of graphics, or other computations with real-time requirements.

Sound is created by defining the \texttt{dsp} function which takes inputs like a time code, an input sample, and a channel and returns an output sample.
The way in which the output sample is generated is left to the programmer and can include, for example, synthesis or sampling.
Extempore's standard library provides help for the sound generation on the sample level as well as composition on the note level (scales, chords, etc.).
One core idea of Extempore is the concept of temporal recursion: a function can schedule another call to itself at a later point in time creating a loop with exact timing that can be modified on the fly.

In the context of this project, Extempore is used for making a style audible as described in Section \ref{sec:viewers.extempore}.

\subsubsection{Music21}
\label{sec:tools.music21}

Music21 \cite{music21} is a Python library for the computational analysis of music.
It includes a set of annotated corpora and analysis tools as well as general music theoretical utilities.
Data from the corpora can be accessed as Python objects and transformed, manipulated, and analyzed in Python.
The example style \texttt{coltrane.json} has been generated using Music21.

\subsubsection{Lilypond}
\label{sec:tools.lilypond}

\textit{Is this used at all?}

\subsubsection{Musescore}

MuseScore \cite{musescore} is an open source music sheet editor.
It can display and play sheet music and supports MusicXML and Lilypond formats.
This project uses it to view and listen to MusicXML representations of styles.
Another idea was to make the harmonizer available as a plugin in MuseScore.

\subsection{Related Research}

\subsubsection{Rohrmeier}

In \autocite{rohrmeier_towards_2011}, Rohrmeier presents a context free grammar for tonal harmony.
It is intended to be generally applicable for western tonal music and is therefore designed to be independent from specific styles of western tonal music.
Since its roots lie in Riemannian theory of harmony, the grammar distinguishes chords as tonic, dominant, and predominant (subdominant) related.
The other fundamental idea, coming from Schenkerian music theory, is that harmony in this kind of music has a recursive structure:
Some sequences of chords on the surface level can be seen as an elaboration of a single harmony on a more abstract, ``structural'' level.
This idea is captured implicitly in the recursive nature of context free grammars and explicitly by distinguishing between functional regions (generating multiple chords) and actual functional harmonies (generating single chords or fixed length sequences of chords).

The grammar is constructed according to multiple levels:
The phrase level deals with single (harmonic) phrases or sequences of phrases.
A single phrase is a well formed harmonic ``sentence'', which can be a whole piece.
On the functional level phrases are composed of functional regions (in terms of tonic, dominant and subdominant), which are recursively composed out of other functional regions and ultimately functional harmonies.
Functional harmonies are translated to scale degrees on the scale degree level (e.g. a dominant harmony generates a $V$ chord).
The scale degree level also contains rules for secondary dominants and falling fifth sequences.
Finally, scale degrees generate actual absolute chords using the current $key$ property on the structural level (e.g., $V$ becomes $C_{maj}$ if $key = F_{maj}$).

The $key$ property is set in the top-level rule (phrase level) for the whole piece but can be modified on the functional level, as every functional harmony can generate a new functional region in which it is the local tonic (i.e., the $key$ is changed for all child nodes).
This allows for several phenomena such as modulation and local tonicization.
Additionally, a change of between major and minor is allowed at this point.

The productions of the grammar are selected to stick to the basic principles of harmonic progression, i.e., a harmony may be prolonged, a dominant implies a tonic, and a subdominant implies a dominant.
Implementing this in a context free grammar with its recursive structure implies that this holds not only for adjacent surface chords but for whole regions.
Flexibility is then added by allowing modulations (as described above) and substitutions (e.g., the $tp$ might replace the $t$ function).
This way, unusual jumps between adjacent chords can be explained by the fact that they belong to different subtrees, which have a simple relation on a higher level in the tree, which is in accordance with music theoretical interpretations.
The sample analyses provided in the paper show that by relying on a very restricted set of basic principles this grammar can still account for very different harmonic phenomena from actual tonal music.

The structural level is left unspecified in the paper, as it depends on the actual style of music and would be different, for example, for jazz as opposed to baroque music.
Therefore, this approach addresses a different (but related) issue compared to ours.
It aims at encoding the fundamental principles of western tonal music harmony as described by Riemannian functional harmony and the assumption of a recursive structure of harmony in a formal system (namely a context free grammar), thereby drawing a relation between music and language.

\subsubsection{Koops - \textsc{HarmTrace}}
The work by Koops \autocite{koops2012model} is a model based system to derive harmonic functions of chords in their tonal context and consists of \textsc{HarmTrace} and the \textsc{HarmTrace Harmonizer}. It is a rule based system written in the programming language Haskell. Given a chord sequence \textsc{HarmTrace} derives the harmonic function of the of a chord in it's tonal context. It describes a grammar to represent chords and the relations between them in them. Based on this representation the \textsc{Harmonizer} creates the best fitting chord sequence to harmonize the melody.

The system involves three steps. First the melody is analyzed using the \textsc{HarmTrace} program. After that the tonality and the and the time signature of the music piece is represented in a data structure that defines a context free grammar. After that the best sequences of chords are selected using the \textsc{HarmTrace Harmonizer}. 

This selection is based on basic heuristics form the harmonization theory, like the circle of fifths and cadences. The system includes four steps: Generating, Selection, Parsing and Post-processing. 

\paragraph{Generating} 
The system takes as single track as input and extracts tonality and rhythm information of the piece using the \textsc{HarmTrace} module and represents it in the context free grammar. In this representation the possible chords are calculated for the root note and a pre-selection is done. Next the probabilities are assigned to the chords in the remaining set, which are calculated using the circle of fifths, where the distance of the melody note to the root note gives the probability. The circle of fifths is used because it corresponds with human perception of harmony. 

\paragraph{Selecting sequences}
In the next step the probabilities are used to generate a list of possible harmonization chord sequences. The list is generated by randomly selecting from the chord candidates. The probability distribution for that is defined by the chord probabilities, calculated before. 

\paragraph{Parsing}
In this step the short chord sequences are combined to a lager piece using the \textsc{HarmTrace} parsing capabilities, so that the best sequence of chords progressions if returned. The best sequence is determined by the best fit with the grammar.

\paragraph{Post-processing}
In the final step the symbolic representation of the music piece is translated in the MIDI format. For that some heuristics are used to ensure that the resulting piece will sound good. 

\paragraph{Relation to our work}
This work is related to our project it the sense that is also uses a symbolic representation of music and creates harmonization of the piece automatically. Similar to our work Koops uses representations to generate new chords and sequences. He also represents the chords in therms of relive distance between the tone and the root similar to our representation.

Other then in our work he uses a pre-selection step to exclude chord sequences from the pool if generated chords. This is done by using the concept of cadences and the circle of fifths. That way he wants to ensure that the result is not bad by chance. We instead regularize the output by giving the system only the limited number of sequences to work with, that are the styles we put in the system at the start. 

Koops also uses the circle of fifths in combination with a stochastic selection to generate new sequences, this is a good idea to ensure that the result will sound good. The disadvantage of this approach is that the result wouldn't sound interesting because it favors the close and common chords. Because of this random generation paired with a strong heuristics selection the system is not inventive enough for us to grant creativity to it.





  
%  LocalWords:  tonicization
